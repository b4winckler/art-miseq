% MiSeq binning
% BjÃ¶rn Winckler

# Input format

MiSeq raw data consists of two fastq files - one for the forward reads and one
for the reverse reads.  The reads in these two files should be in the same
order.  The forward reads consist of 301 bp from the coding strand and the
reverse reads consists of 301 bp from the noncoding strand.  Both reads are in
the 5' to 3' direction which means that the reverse reads must be reverse
complemented before they can be merged with the forward reads.

An example fastq header looks like this:

    @HWI-M01548R:6:000000000-A8JPR:1:1101:18848:1551 1:N:0:TCCTGAGCTATCCTCT

The headers from a forward and reverse read should be identical apart from the
string after the space which starts with `1:` for a forward read and `2:` for a
reverse read.  The 16 bp at the end are the *sample barcode* which is used to
identify which sample the read belongs to.  The barcode is broken down into two
*indexes* of 8 bp each.  In this example index1 is `TATCCTCT` (the last 8 bp),
and index2 is `TCCTGAGC` (the first 8 bp in reverse complement).

Every forward read begins with a 16 bp *bin identifier*, followed by 0-2 bp of
phasing nucleotides (to be ignored), followed by the forward primer 340F.  Each
reverse read (before reverse complementing) begins with 1-3 phasing nucleotides
(`A`, `CA` or `GCA`) followed by the reverse primer 806R (in reverse
complement).

 Primer     Sequence
-------     ---------
340F        `TCCTACGGGAGGCAGCAGT`
806R        `ATTAGATACCCTGGTAGTCC`

Here is an example of the start of a forward read (with bin identifier
`CCAACCTTCTATGGCG`, followed by 1 phasing nucleotide, 340F, and then the
sequence `AGGGAAT`):

    CCAACCTTCTATGGCGATCCTACGGGAGGCAGCAGTAGGGAAT

And here is an example of the start of a reverse read (with phase `CA`,
followed by 806R in reverse complement, and then the sequence `CCTGTTTGCT`):

    CAGGACTACCAGGGTATCTAATCCTGTTTGCT


# Preprocessing

## Splitting by barcode

Since MiSeq fastq files are so big it is best to split them up into one fastq
per sample.  I have written a specialized tool called [iseq][iseq] which can do this efficiently:

    zcat big.fastq.gz | iseq split --barcodes barcodes.fasta

The file `barcodes.fasta` is a normal fasta file where the header is used to
name each sample and the corresponding sequence is the sample barcode.  The
tool will create one file for each entry in `barcodes.fasta`.  Note that it is
highly recommended to only use letters, numbers and underscores in the headers
(e.g. `>sample_01` is good) since they are used to name files.  The files will
be placed in the current directory, use `--output PATH` to write the output to
the directory named by `PATH`.

## Merging paired reads

To merge the files containing forward reads (`fwd.fastq`) and reverse reads
(`rev.fastq`) into one file, use [USEARCH][usearch]:

    usearch -fastq_mergepairs fwd.fastq -reverse rev.fastq \
            -fastq_truncqual 3 -fastqout merged.fastq

The result is a file `merged.fastq` which contains all overlapping paired reads
which could successfully be merged.  Note that the above command will likely
fail if you try to run it on the original MiSeq data without first splitting
by barcode since the 32 bit version of USEARCH cannot handle very large files.

## Quality filtering

Quality filtering is done to remove reads with many low quality bases.  Again
[USEARCH][usearch] can be used for this task:

    usearch -fastq_filter merged.fastq -fastq_maxee 0.5 \
            -fastaout filtered.fasta

The above command discards reads with more than 0.5 maximum expected errors and
writes the good quality reads to the file `filtered.fasta`.  The author of
USEARCH explains why [filtering by average Q is a bad idea][usearch-avgq] and
this is the reason why we filter by maximum expected errors instead.

The number of good quality reads is half of the number of lines, which can be
seen with:

    wc -l filtered.fasta

## Stripping primers

Strip forward and reverse primers and phasing nucleotides:

    iseq strip --skip 16 --shift 2 --errors 2 \
        --input filtered.fasta TCCTACGGGAGGCAGCAGT | \
        iseq strip --shift 3 --errors 2 --reverse \
        ATTAGATACCCTGGTAGTCC > stripped.fasta

## Sorting by bins

To simplify upstreams steps we next sort the fasta files by their reads.  Since
the bin identifier consists of the first 16 bp this also ensures that all reads
that belong to the same bin are listed consequtively in the fasta file.  The
sorting can be done as follows:

    paste - - < stripped.fasta | sort -t "$(/bin/echo -e '\t')" \
        -k2 | tr "\t" "\n" > sorted.fasta

The `paste` command joins two lines at a time and the complicated-looking
argument to `sort` ensures it separates keys by tabs and sorts on the second
key.


[sff2fastq]: https://github.com/indraniel/sff2fastq
[usearch-script]: http://drive5.com/python/
[fastqc]: http://www.bioinformatics.babraham.ac.uk/projects/fastqc/
[usearch]: http://www.drive5.com/usearch/manual/
[usearch-fastq_stats]: http://www.drive5.com/usearch/manual/fastq_stats.html
[usearch-choose]: http://www.drive5.com/usearch/manual/fastq_choose_filter.html
[qiime]: http://qiime.org/
[uparse-pipeline]: http://www.drive5.com/usearch/manual/uparse_pipeline.html
[greengenes]: http://greengenes.secondgenome.com
[iseq]: https://github.com/b4winckler/iseq
[usearch-avgq]: http://www.drive5.com/usearch/manual/avgq.html
